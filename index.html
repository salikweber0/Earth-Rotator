<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Interactive Earth</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        body {
            background: radial-gradient(ellipse at center, #0d1b2a 0%, #000000 100%);
            font-family: 'Arial', sans-serif;
            justify-items: center;
            justify-content: center;
        }
        #container {
            width: 100vw;
            height: 100vh;
            cursor: grab;
        }
        #container:active {
            cursor: grabbing;
        }
        .info-box {
            position: absolute;
            top: 30px;
            left: 20px;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            padding: 20px 30px;
            border-radius: 15px;
            color: white;
            z-index: 100;
            border: 1px solid rgba(255, 255, 255, 0.1);
            justify-content: center;
        }
        .info-box h1 {
            font-size: 28px;
            margin-bottom: 8px;
            font-weight: 600;
        }
        .info-box p {
            font-size: 14px;
            opacity: 0.9;
            color: #00d4ff;
        }
    </style>
</head>
<body>
    <div class="info-box">
        <h1>üåç Interactive Earth</h1>
        <p>Drag to rotate in any direction.</p>
        <p>Created by Shaikh Salik</p>
    </div>
    <div id="container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, earth, atmosphere, stars;
        let isDragging = false;
        let previousMouse = { x: 0, y: 0 };
        let velocity = { x: 0, y: 0 };

        function init() {
            // Scene
            scene = new THREE.Scene();

            // Camera
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.z = 3;

            // Renderer
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                alpha: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('container').appendChild(renderer.domElement);

            // Lighting
            const ambient = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambient);

            const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
            sunLight.position.set(5, 3, 5);
            scene.add(sunLight);

            // Load Earth Texture from URL
            const textureLoader = new THREE.TextureLoader();
            textureLoader.setCrossOrigin('anonymous');
            
            const earthTexture = textureLoader.load(
                'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/earth_atmos_2048.jpg',
                () => {
                    console.log('Earth texture loaded successfully!');
                },
                undefined,
                (err) => {
                    console.log('Texture load error, using fallback');
                    // Fallback to procedural texture if loading fails
                    createFallbackTexture();
                }
            );

            // Earth Geometry
            const geometry = new THREE.SphereGeometry(0.8, 128, 128);
            const material = new THREE.MeshPhongMaterial({
                map: earthTexture,
                shininess: 20,
                specular: 0x333333
            });

            earth = new THREE.Mesh(geometry, material);
            scene.add(earth);

            // Atmosphere Glow
            const atmosphereGeo = new THREE.SphereGeometry(0.86, 64, 64);
            const atmosphereMat = new THREE.MeshBasicMaterial({
                color: 0x66bbff,
                transparent: true,
                opacity: 0.3,
                side: THREE.BackSide
            });
            atmosphere = new THREE.Mesh(atmosphereGeo, atmosphereMat);
            scene.add(atmosphere);

            // Stars
            createStars();

            // Event Listeners
            addEventListeners();

            // Animation
            animate();
        }

        function createFallbackTexture() {
            // Create better fallback texture
            const canvas = document.createElement('canvas');
            canvas.width = 4096;
            canvas.height = 2048;
            const ctx = canvas.getContext('2d');
            
            // Ocean base
            const gradient = ctx.createRadialGradient(
                canvas.width/2, canvas.height/2, 0,
                canvas.width/2, canvas.height/2, canvas.height
            );
            gradient.addColorStop(0, '#2e5266');
            gradient.addColorStop(0.5, '#1a3a52');
            gradient.addColorStop(1, '#0e1f2e');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Continents
            ctx.fillStyle = '#3a5a40';
            
            // More realistic land masses
            drawLandMass(ctx, 600, 500, 300, 250); // North America
            drawLandMass(ctx, 800, 1100, 200, 300); // South America
            drawLandMass(ctx, 2000, 900, 250, 350); // Africa
            drawLandMass(ctx, 2100, 500, 200, 150); // Europe
            drawLandMass(ctx, 2800, 650, 450, 350); // Asia
            drawLandMass(ctx, 3200, 1300, 180, 160); // Australia
            
            // Add texture variation
            ctx.fillStyle = '#4a6741';
            for(let i = 0; i < 200; i++) {
                ctx.beginPath();
                ctx.arc(
                    Math.random() * canvas.width,
                    Math.random() * canvas.height,
                    Math.random() * 40 + 10,
                    0, Math.PI * 2
                );
                ctx.fill();
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            earth.material.map = texture;
            earth.material.needsUpdate = true;
        }

        function drawLandMass(ctx, x, y, w, h) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(Math.random() * 0.5 - 0.25);
            ctx.beginPath();
            ctx.ellipse(0, 0, w, h, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Add some detail
            for(let i = 0; i < 5; i++) {
                ctx.beginPath();
                ctx.ellipse(
                    (Math.random() - 0.5) * w * 0.8,
                    (Math.random() - 0.5) * h * 0.8,
                    w * 0.3,
                    h * 0.3,
                    0, 0, Math.PI * 2
                );
                ctx.fill();
            }
            ctx.restore();
        }

        function createStars() {
            const starsGeo = new THREE.BufferGeometry();
            const starsMat = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.02,
                transparent: true,
                opacity: 0.8
            });

            const positions = [];
            for(let i = 0; i < 20000; i++) {
                const x = (Math.random() - 0.5) * 2000;
                const y = (Math.random() - 0.5) * 2000;
                const z = (Math.random() - 0.5) * 2000;
                positions.push(x, y, z);
            }

            starsGeo.setAttribute('position', 
                new THREE.Float32BufferAttribute(positions, 3)
            );

            stars = new THREE.Points(starsGeo, starsMat);
            scene.add(stars);
        }

        function addEventListeners() {
            const canvas = renderer.domElement;

            // Mouse Events
            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMouse = { x: e.clientX, y: e.clientY };
            });

            canvas.addEventListener('mousemove', (e) => {
                if(!isDragging) return;

                const deltaX = e.clientX - previousMouse.x;
                const deltaY = e.clientY - previousMouse.y;

                velocity.y = deltaX * 0.01;
                velocity.x = deltaY * 0.01;

                earth.rotation.y += velocity.y;
                earth.rotation.x += velocity.x;

                previousMouse = { x: e.clientX, y: e.clientY };
            });

            canvas.addEventListener('mouseup', () => {
                isDragging = false;
            });

            // Touch Events
            canvas.addEventListener('touchstart', (e) => {
                isDragging = true;
                previousMouse = {
                    x: e.touches[0].clientX,
                    y: e.touches[0].clientY
                };
            });

            canvas.addEventListener('touchmove', (e) => {
                if(!isDragging) return;

                const deltaX = e.touches[0].clientX - previousMouse.x;
                const deltaY = e.touches[0].clientY - previousMouse.y;

                velocity.y = deltaX * 0.01;
                velocity.x = deltaY * 0.01;

                earth.rotation.y += velocity.y;
                earth.rotation.x += velocity.x;

                previousMouse = {
                    x: e.touches[0].clientX,
                    y: e.touches[0].clientY
                };
            });

            canvas.addEventListener('touchend', () => {
                isDragging = false;
            });

            // Window Resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function animate() {
            requestAnimationFrame(animate);

            // Momentum
            if(!isDragging) {
                velocity.x *= 0.95;
                velocity.y *= 0.95;

                earth.rotation.x += velocity.x;
                earth.rotation.y += velocity.y;

                // Auto rotate slowly
                if(Math.abs(velocity.x) < 0.001 && Math.abs(velocity.y) < 0.001) {
                    earth.rotation.y += 0.001;
                }
            }

            atmosphere.rotation.y += 0.0005;
            stars.rotation.y += 0.0001;

            renderer.render(scene, camera);
        }

        window.onload = init;
    </script>
</body>
</html>